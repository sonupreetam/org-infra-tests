# Reusable Sign and Verify Workflow
# ==================================
# Implements keyless container image signing using Sigstore/Cosign.
# Supports both full verification (signature + attestations) and signature-only mode.

name: Reusable Sign and Verify

on:
  workflow_call:
    inputs:
      image_name:
        description: 'Comma-separated full image names (e.g., ghcr.io/org/image,quay.io/org/image)'
        required: true
        type: string
      digest:
        description: 'Pushed image digest to sign/verify'
        required: true
        type: string
      allowed_identity_regex:
        description: 'Regex for Cosign certificate identity (optional, defaults to org-level)'
        required: false
        type: string
      sign_environment:
        description: 'Environment name to gate signing (for required reviewers)'
        required: false
        type: string
        default: 'signing'
      registry_username:
        description: 'Username for GHCR login (defaults to github.actor)'
        required: false
        type: string
      verify_attestations:
        description: 'Verify SBOM and SLSA attestations (disable for promoted images)'
        required: false
        type: boolean
        default: true
      skip_sign:
        description: 'Skip signing, only verify (for pre-promotion checks)'
        required: false
        type: boolean
        default: false
    secrets:
      registry_token:
        description: 'Optional GHCR token. If not provided, falls back to GITHUB_TOKEN.'
        required: false
      quay_username:
        description: 'Quay.io username/robot for login (only needed if signing quay.io images)'
        required: false
      quay_password:
        description: 'Quay.io password/token for login (only needed if signing quay.io images)'
        required: false

permissions:
  packages: none
  id-token: none

concurrency:
  group: reusable-sign-verify-${{ inputs.image_name }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  sign-and-verify:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      packages: write   # Push signature as OCI artifact to registry
      id-token: write   # Request OIDC token for keyless signing via Sigstore

    environment: ${{ inputs.skip_sign && '' || inputs.sign_environment }}
    steps:
      # Registry authentication for signature push
      - name: Log in to GHCR
        if: contains(inputs.image_name, 'ghcr.io')
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          registry: ghcr.io
          username: ${{ inputs.registry_username || github.actor }}
          password: ${{ secrets.registry_token || github.token }}

      - name: Log in to Quay
        if: contains(inputs.image_name, 'quay.io')
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          registry: quay.io
          username: ${{ secrets.quay_username }}
          password: ${{ secrets.quay_password }}

      - name: Validate digest format
        env:
          DIGEST: ${{ inputs.digest }}
          IMAGE_INPUT: ${{ inputs.image_name }}
        run: |
          # Ensure digest is a valid sha256 format (immutability guarantee)
          # Protects against accidentally signing a tag (which can be overwritten)
          if ! echo "$DIGEST" | grep -qE '^sha256:[a-f0-9]{64}$'; then
            echo "::error::Invalid digest format. Expected 'sha256:<64-hex-chars>', got: '$DIGEST'"
            exit 1
          fi
          # Warn if image_name contains a tag (ignored with digest, may indicate caller mistake)
          # Common error: passing "image:tag" when "image" + digest is expected
          if echo "$IMAGE_INPUT" | grep -qE ':[^/@]+$'; then
            echo "::warning::image_name appears to contain a tag. Tags are ignored when using digest references."
          fi

      - name: Install Cosign
        uses: sigstore/cosign-installer@faadad0cce49287aee09b3a48701e75088a2c6ad # v4.0.0

      - name: Sign images
        if: ${{ !inputs.skip_sign }}
        env:
          IMAGE_INPUT: ${{ inputs.image_name }}
          DIGEST: ${{ inputs.digest }}
        run: |
          # Sign each image (digest ensures exact match to build)
          IFS=',' read -ra IMAGES <<< "$IMAGE_INPUT"
          for NAME in "${IMAGES[@]}"; do
            NAME="${NAME// /}"  # trim whitespace
            echo "Signing: ${NAME}@${DIGEST}"
            cosign sign --yes "${NAME}@${DIGEST}"
          done

      - name: Verify signature and attestations
        env:
          IMAGE_INPUT: ${{ inputs.image_name }}
          DIGEST: ${{ inputs.digest }}
          IDENTITY_REGEX: ${{ inputs.allowed_identity_regex || format('https://github.com/{0}/.*', github.repository_owner) }}
          VERIFY_ATTESTATIONS: ${{ inputs.verify_attestations }}
        run: |
          # Use first image (all copies share same digest)
          IMAGE="${IMAGE_INPUT%%,*}@${DIGEST}"
          IMAGE="${IMAGE# }"  # trim leading space

          # Debug: Show what identity we're looking for vs what the signature has
          echo "::group::Debug: Certificate Identity Info"
          echo "Expected identity regex: $IDENTITY_REGEX"
          echo "Expected OIDC issuer: https://token.actions.githubusercontent.com"
          echo "Image: $IMAGE"
          echo ""
          echo "Actual certificate from signature (using permissive verification):"
          if cosign verify \
            --certificate-identity-regexp='.*' \
            --certificate-oidc-issuer-regexp='.*' \
            --output json "$IMAGE" 2>/dev/null | jq -r '.[0].optional // empty | {
              "Subject": .Subject,
              "Issuer": .Issuer, 
              "OIDC Issuer": ."1.3.6.1.4.1.57264.1.1",
              "GitHub Workflow Trigger": ."1.3.6.1.4.1.57264.1.2",
              "GitHub Workflow SHA": ."1.3.6.1.4.1.57264.1.3",
              "GitHub Workflow Name": ."1.3.6.1.4.1.57264.1.4",
              "GitHub Workflow Repository": ."1.3.6.1.4.1.57264.1.5",
              "GitHub Workflow Ref": ."1.3.6.1.4.1.57264.1.6"
            }' 2>/dev/null; then
            echo "✓ Signature found and decoded"
          else
            echo "⚠ Could not decode certificate - signature may not exist or different format"
            # Try raw output
            cosign verify --certificate-identity-regexp='.*' --certificate-oidc-issuer-regexp='.*' "$IMAGE" 2>&1 || true
          fi
          echo "::endgroup::"

          COSIGN_FLAGS=(
            "--certificate-identity-regexp=$IDENTITY_REGEX"
            "--certificate-oidc-issuer=https://token.actions.githubusercontent.com"
          )

          echo "Verifying signature: $IMAGE"
          cosign verify "${COSIGN_FLAGS[@]}" "$IMAGE"

          if [[ "$VERIFY_ATTESTATIONS" == "true" ]]; then
            echo "Verifying SLSA provenance: $IMAGE"
            cosign verify-attestation "${COSIGN_FLAGS[@]}" --type slsaprovenance "$IMAGE"

            echo "Verifying SBOM: $IMAGE"
            cosign verify-attestation "${COSIGN_FLAGS[@]}" --type spdx "$IMAGE"
          fi

      - name: Summary
        env:
          VERIFY_ATTESTATIONS: ${{ inputs.verify_attestations }}
          SKIP_SIGN: ${{ inputs.skip_sign }}
        run: |
          echo "All verifications passed!"
          echo "Signed: $([[ "$SKIP_SIGN" == "true" ]] && echo "No (verify only)" || echo "Yes")"
          echo "Attestations: $([[ "$VERIFY_ATTESTATIONS" == "true" ]] && echo "SLSA + SBOM" || echo "signature only")"

