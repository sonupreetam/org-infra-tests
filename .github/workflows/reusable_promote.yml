# Reusable Promote Image Workflow
# ================================
# Promotes container images between registries with supply chain security.
#
# Security features:
#   - Signature verification before promotion (Sigstore/Cosign)
#   - Digest-based references (immutable)
#   - Preserves SBOM and provenance attestations
#   - Tag immutability protection with audit logging
#
# Usage: called from release workflows after images pass CI/security gates.

name: Reusable Promote Image

on:
  workflow_call:
    inputs:
      source_registry:
        description: 'Source registry (e.g., ghcr.io)'
        required: true
        type: string
      source_image:
        description: 'Source image name without registry (e.g., org/image-name)'
        required: true
        type: string
      source_tag:
        description: 'Source tag to look up (e.g., sha-abc123)'
        required: true
        type: string
      dest_registry:
        description: 'Destination registry (e.g., quay.io)'
        required: true
        type: string
      dest_image:
        description: 'Destination image name without registry (defaults to source_image)'
        required: false
        type: string
      dest_tag:
        description: 'Primary destination tag (e.g., v1.2.3)'
        required: true
        type: string
      additional_tags:
        description: 'Comma-separated additional tags (e.g., 1.2,1,latest)'
        required: false
        type: string
      create_semver_tags:
        description: 'Auto-create semver tags from dest_tag (e.g., v1.2.3 → 1.2, 1)'
        required: false
        type: boolean
        default: true
      verify_source_signature:
        description: 'Verify source image is signed before promoting (recommended)'
        required: false
        type: boolean
        default: true
      allowed_identity_regex:
        description: 'Regex for Cosign certificate identity verification'
        required: false
        type: string
      fail_if_dest_exists:
        description: 'Fail if destination tag already exists (immutability protection)'
        required: false
        type: boolean
        default: true
    secrets:
      source_token:
        description: 'Token for source registry (falls back to GITHUB_TOKEN for GHCR)'
        required: false
      dest_username:
        description: 'Username for destination registry'
        required: true
      dest_password:
        description: 'Password for destination registry'
        required: true
    outputs:
      digest:
        description: 'Image digest that was promoted'
        value: ${{ jobs.promote.outputs.digest }}
      dest_image_full:
        description: 'Full destination image reference'
        value: ${{ jobs.promote.outputs.dest_image_full }}

permissions:
  contents: none
  packages: none

concurrency:
  group: reusable-promote-${{ inputs.source_image }}-${{ inputs.dest_tag }}
  cancel-in-progress: false  # Never cancel promotions mid-flight

jobs:
  promote:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      packages: read  # For GHCR access (pull source image)
    outputs:
      digest: ${{ steps.source.outputs.digest }}
      dest_image_full: ${{ steps.copy.outputs.dest_image_full }}
    steps:
      - name: Install crane
        uses: imjasonh/setup-crane@31b88efe9de28ae0ffa220711af4b60be9435f6e # v0.4

      - name: Install Cosign
        uses: sigstore/cosign-installer@faadad0cce49287aee09b3a48701e75088a2c6ad # v4.0.0

      - name: Log in to source registry
        env:
          TOKEN: ${{ secrets.source_token || secrets.GITHUB_TOKEN }}
          REGISTRY: ${{ inputs.source_registry }}
          ACTOR: ${{ github.actor }}
        run: |
          echo "$TOKEN" | crane auth login "$REGISTRY" -u "$ACTOR" --password-stdin
          echo "$TOKEN" | cosign login "$REGISTRY" -u "$ACTOR" --password-stdin

      - name: Log in to destination registry
        env:
          PASSWORD: ${{ secrets.dest_password }}
          USERNAME: ${{ secrets.dest_username }}
          REGISTRY: ${{ inputs.dest_registry }}
        run: |
          echo "$PASSWORD" | crane auth login "$REGISTRY" -u "$USERNAME" --password-stdin
          echo "$PASSWORD" | cosign login "$REGISTRY" -u "$USERNAME" --password-stdin

      - name: Check destination tag availability
        env:
          DEST: ${{ inputs.dest_registry }}/${{ inputs.dest_image || inputs.source_image }}:${{ inputs.dest_tag }}
          FAIL_IF_EXISTS: ${{ inputs.fail_if_dest_exists }}
        run: |
          if crane manifest "$DEST" &>/dev/null; then
            if [[ "$FAIL_IF_EXISTS" == "true" ]]; then
              echo "::error::Destination tag already exists: $DEST"
              echo "Set fail_if_dest_exists: false to overwrite (breaks immutability)"
              exit 1
            else
              echo "::warning::Overwriting existing tag: $DEST (immutability bypassed)"
            fi
          else
            echo "✓ Destination tag available"
          fi

      - name: Get source digest
        id: source
        env:
          SOURCE_IMAGE: ${{ inputs.source_registry }}/${{ inputs.source_image }}:${{ inputs.source_tag }}
        run: |
          echo "Looking up: ${SOURCE_IMAGE}"
          DIGEST=$(crane digest "${SOURCE_IMAGE}" 2>/dev/null) || {
            echo "::error::Source image not found: ${SOURCE_IMAGE}"
            echo "Make sure the image was built on main before tagging for release."
            exit 1
          }

          # Validate digest format (immutability guarantee)
          if ! echo "$DIGEST" | grep -qE '^sha256:[a-f0-9]{64}$'; then
            echo "::error::Invalid digest format. Expected 'sha256:<64-hex-chars>', got: '$DIGEST'"
            exit 1
          fi

          echo "digest=${DIGEST}" >> "$GITHUB_OUTPUT"
          echo "Source digest: ${DIGEST}"

      - name: Verify source signature
        if: ${{ inputs.verify_source_signature }}
        env:
          SOURCE: ${{ inputs.source_registry }}/${{ inputs.source_image }}@${{ steps.source.outputs.digest }}
          IDENTITY_REGEX: ${{ inputs.allowed_identity_regex || format('https://github.com/{0}/.*', github.repository_owner) }}
        run: |
          echo "Verifying source image signature..."
          cosign verify "$SOURCE" \
            --certificate-identity-regexp="$IDENTITY_REGEX" \
            --certificate-oidc-issuer=https://token.actions.githubusercontent.com
          echo "Source image signature verified"

      - name: Promote image and apply tags
        id: copy
        env:
          SOURCE: ${{ inputs.source_registry }}/${{ inputs.source_image }}@${{ steps.source.outputs.digest }}
          DEST_IMAGE: ${{ inputs.dest_registry }}/${{ inputs.dest_image || inputs.source_image }}
          DEST_TAG: ${{ inputs.dest_tag }}
          ADDITIONAL_TAGS: ${{ inputs.additional_tags }}
          CREATE_SEMVER: ${{ inputs.create_semver_tags }}
          DIGEST: ${{ steps.source.outputs.digest }}
        run: |
          DEST="${DEST_IMAGE}:${DEST_TAG}"
          echo "Copying ${SOURCE} → ${DEST} (with signatures and attestations)"

          # cosign copy preserves signatures and attestations
          cosign copy "$SOURCE" "$DEST"
          echo "dest_image_full=${DEST_IMAGE}" >> "$GITHUB_OUTPUT"

          # For additional tags, use destination (faster, same-registry copy)
          DEST_REF="${DEST_IMAGE}@${DIGEST}"

          # Add semver tags (v1.2.3 → 1.2, 1)
          if [[ "$CREATE_SEMVER" == "true" && "$DEST_TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            VERSION="${DEST_TAG#v}"
            echo "Adding semver tag: ${DEST_IMAGE}:${VERSION%.*}"
            crane tag "${DEST_REF}" "${VERSION%.*}"
            echo "Adding semver tag: ${DEST_IMAGE}:${VERSION%%.*}"
            crane tag "${DEST_REF}" "${VERSION%%.*}"
          fi

          # Add custom tags
          if [[ -n "$ADDITIONAL_TAGS" ]]; then
            IFS=',' read -ra TAGS <<< "$ADDITIONAL_TAGS"
            for TAG in "${TAGS[@]}"; do
              TAG="${TAG// /}"  # trim whitespace
              echo "Adding tag: ${DEST_IMAGE}:${TAG}"
              crane tag "${DEST_REF}" "${TAG}"
            done
          fi

          echo "Promotion complete"
